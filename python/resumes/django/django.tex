\documentclass[12pt, a4paper]{paper}
\usepackage{babel}
\usepackage{graphicx}
\usepackage[margin=2.5cm]{geometry}
%\hfuzz=5.002pt 

\title{Django \\
  %\hfill\includegraphics[height=3cm]{../images/universidade.png}
  \vspace{-3cm}
}
\subtitle{Web framework python}
\author{João Vitor Rezende Moura - 1221184773}
\institution{UNIT - Universidade Tiradentes}

\begin{document}
\maketitle
\hrule
\begin{abstract}
  O desenvolvimento Web é uma necessidade de grande nos dias atuais, e será futu-
  ramente, com isso, visa-se a necessidade da criação e utilização de ferramentas que
  proporcionem uma melhor qualidade, velocidade e adaptabilidade dos projetos.
  Com isso, o web framework Django foi uma das soluções que utiliza da linguagem
  python para fazer o devesenvolvimento de aplicações Web.
\end{abstract}
\vspace{-0.6cm}


\begin{keywords}
  Django, Web, Framework, Desenvolvimento, Python, MVT
\end{keywords}
\hrule
\section{Oque é Django?} % (fold)
\label{sec:Oque é Django?}
O Django é um web framework que segue a arquitetura MVT, e com ele
podemos criar aplicações web com maior facilidade e rapidez, pelo fato de
ele cuidar da maioria dos detalhes intrísecos do desenvolvimento web. Como
uma das suas características, é que ele é de uso livre, e possui código open -
source.
Dentre algumas das ferramentas que o Django inclui, podemos listar algumas como:

\begin{itemize}
  \item Site maps
  \item Authentication
  \item Context Administrator
  \item RSS Feeds
\end{itemize}

Além disso, possui ferramentas que possibilitam uma maior segurança da
aplicação, e muitas outras ferramentas voltadas para o desenvolvedor.


\subsection{Instalação e inicialização do framework} % (fold)
\label{sub:Instalação e inicialização do framework}
Dentro do python, é comum a utilização de ambientes virtuais, pois ele facilita
e organiza o uso de bibliotecas que podem ser baixadas para o uso da nossa
aplicação. Com isso, para inicializarmos nosso ambiente virtual e instalar o
framework no ambiente virtual, podemos usar as seguintes instruções bash

\begin{verbatim}
  $ python -m venv nome_ambiente_virtual

  # A depender da plafatorma de desenvolvimento escolhida,
  # devemos ativar o ambiente virtual de forma diferente,
  # nesse caso, iremos instruir com base nas plataformas
  # MacOs e Linux/Unix2 Instalação e inicialização do framework

  $ source ./nome_ambiente_virtual/bin/activate
  $ pip install django
\end{verbatim}

%Posteriormente a isso, temos no nosso terminal, uma das ferramentas que
%instalamos junto com o Django, que é sua CLI, a qual permite iniciarmos o
%projeto e criar automaticamente sua estrutura e os arquivos necessários para
cosntruirmos uma aplicação Django. Para criarmos a aplicação, devemos
usar o documando:

\begin{verbatim}
  $django-admin startproject nomeProjeto
\end{verbatim}

Na parte final do comando temos por exemplo a opção de adicionar o
projeto dentro de um diretório específico que será criado para o projeto ou
dentro do diretório que o comando está sendo executado, para definir isso,
devemos deixar em branco, ou adicionar um ponto, respectivamente. Após
essas configurações, instalações e comandos, podemos usbir o Django sem
sequer necessitar criar alguma interface, pois ele possui uma tela inicial, que
nos comunica se a instalação e criação do nosso projeto foi feito de maneira
correta. Para isso, podemos usar o seguinte comando:

\begin{verbatim}
  $python manage.py runserver
\end{verbatim}

Com isso, estaremos rodando nossa aplicação, e ela pode ser acessada
dentro do localhost, na porta 8000, que são definidos por padrão, mas caso
necessário, podemos ser modificados nas configurações.
Posteriormente a isso, temos que nosso projeto foi criado com uma esrtu-
tura específica, que vai ser destrinchada a seguir:

\subsection{Estrutura dos arquivos criados pelo Django} % (fold)
\label{sub:Estrutura dos arquivos criados pelo Django}

Os arquivos que foram criados dentro do nosso projeto possuem características
distintas dos outros devido á funcionalidade que lhe é atribuida, eles se car-
acterizam por serem:
\begin{itemize}
  \item \textbf{manage.py:} Esse é o arquivo utilitário da CLI do django, que é usado
como django-admin. Ele nos permite interagir com o projeto de várias
maneiras.2 Instalação e inicialização do framework

  \item \textbf{db.sqlite3:} É nossa base de dados, por configuração o SQLite é a
nossa base de dados por ser leve e ser integrado com o python por
natureza, não necessitando de configurações para que funcione desde
o início. Outras bases de dados podem substituir a mesma posterior-
mente, mas para teste, ela é recomendada.

  \item \textbf{\_\_init\_\_.py:} Arquivo de inicialização do pacote. Nosso projeto é
desenvolvido como um pacote python, sendo assim, quando o mesmo é
chamado, é necessário um arquivo de inicialização para que o mesmo
seja executado na chamada do nosso pacote.

  \item \textbf{wsgi.py:} Um entry-point para servidores web que são compatíveis
com WSGI (Web Server Gateway Interface)

  \item \textbf{asgi.py:} Funciona como o WSGI, mas de forma assíncrona

  \item \textbf{settings.py:} Arquivo de configurações do nosso projeto, nos permite
configurar até a forma como as variáveis de ambiente do projeto se
comportam, até mesmo em qual pasta os arquivos estáticos se local-
izam.

  \item \textbf{urls.py:} As declarações de URL do nosso projeto Django funcionam
como uma tabela, que permite especificarmos as URLs que podem ser
acessadas no nosso site.
\end{itemize}

Cada um desses arquivos possuem configurações padrões, que são mínimas
para o funcionamento do Django.


\subsection{Django.settings e funcionamento do framework} % (fold)
\label{sub:Django.settings e funcionamento do framework}
O funcionamento do framework está intrísecamento ligado ao seu arquivo de
configurações, pois é ele que faz o ”meio de campo” entre todas as funcional-
idades da ferramenta, por isso merece uma atenção em especial. Dentro dele
teremos logo de início, a nossa ligação com o banco de dados, que é feito por
meio da biblioteca pathlib, que define a pasta a qual se localiza nossa base
de dados que foi criada junto com o projeto.
Temos que o django funciona por meio da ideia de ”apps”, como se cada
parte da nossa aplicação fosse um app dedicado, ou ela fosse um app como
um todo, e isso pode ser definido por meio de subprojetos dentro do qual
estamos atualmente — esse tópico será tocado com mais detalhes e calma
posteriormente — temos também que o funcionamento do Django permite a
presença de middlewares 

\subsection{Criando as primeiras urls no Django} % (fold)
\label{sub:Criando as primeiras urls no Django}
Após criarmos nossa primeira aplicação, e vermos que sua instalação foi feita
de maneira correta e completa, podemos assim criar nossas primeiras URLs,
para que elas sejam acessadas dno navegador. Devemos nos direcionar ao
arquivo de \texttt{urls.py}, dentro dela temos o seguinte:

\begin{verbatim}
from django.contrib import admin
from django.urls import path
  
urlpatterns = [
  path(’admin/’, admin.site.urls),
]
\end{verbatim}

Esse código permite que nós nos comuniquemos com os servidores por meio do 
protocolo HTTP ( Hyper Text Transfer Protocol), que nos permite fazer requisições
dos dados ao servidor, e ele nos responder com as informações desejada.
 
Esse protocolo possui uma variação que é o HTTPS, que é sua versão que possui uma 
camada extra de segurança, que permite uma maior responsabilidade do lado do 
desenvolvedor e uma maior segurança do lado do cliente. 

Com isso, podemos assim, implementar uma URL customizada da seguinte forma:

\begin{verbatim}
from django.contrib import admin
from django.urls import path 
from django.http import HttpResponse

def view(request):
  return HttpResponse(’Voltando código’)

urlspatterns = [
  path(’blog/’, view)
]
\end{verbatim}

Assim, quando criarmos essa função e essa url, vamos poder acessar essa
url no nosso navegador, e ele vai prover o conteúdo disponibilizado pela
função para que nós possamos usar ele para disponibilizar conteúdo para a
requisição

\newpage
\section{Criando nossas primeira aplicações web}% (fold)
\label{sec:Criando nossas primeira aplicações web}

\subsection{Criando apps com o manage.py} % (fold)
\label{sub:Criando apps com o manage.py}
Os apps dentro do Django, são como uma subcategoria do projeto, que podem
ser criadas várias dentro de um mesmo projeto, e isso é muito útil quando
temos por exemplo, um projeto que deve ter duas formas de aplicação com-
pletamente diferentes, como um e-commerce que deve ter a parte de compra
e venda de produtos feita pelos usuários, e a parte administrativa das con-
tas que não tem acesso as informações de compra e venda (necessariamente
diretamente), mas que é usada para ver as estatísticas de acesso e uso do site.
Tendo esse exemplo em mente, visa-se a necessidade e a utilidade do uso
de apps dentro do Django, para criarmos o nosso, devemos usar o comando:

\begin{verbatim}
$python3 manage.py startapp nome_do_app
\end{verbatim}

Quando criarmos nosso app, teremos numa nova pasta que com ela ter-
emos assim uma nova forma de criar nosso site, e organizar ele da maneira
mais fácil.

Arquivo views.py e configuração de urls
Quando criarmos o app da nossa aplicação, temos dentro dele um arquivo
em particular que não está no projeto como um todo, que é o arquivo de
views.py, dentro dele podemos colocar as views da nossa aplicação, e per-
mitir um funcionamento mais clean e melhor da nossa aplicação, além do
fato de que no arquivo de urls, organizarmos ele apenas com os paths das
nossas urls.
Temos também que podemos aninhar as urls e portanto as views da nossa
aplicação. Para isso, devemos ir dentro do nosso app e especificar as views
e criar o arquivo de urls.py, além de configurar as urls dentro do arquivo
do projeto em sim, como a seguir:

\paragraph{projeto/urls.py} % (fold)
\label{par:projeto/urls.py}
\begin{verbatim}
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
  path(’blog/’, include(’blog.urls’)),
  path(’admin/’, admin.site.urls),
]
\end{verbatim}

\paragraph{blog/views.py} % (fold)
\label{par:blog/views.py}

\begin{verbatim}
from django.http import HttpResponse

def blog(request):
  return HttpResponse("retornando da página inicial do blog")
\end{verbatim}

\paragraph{blog/urls.py} % (fold)
\label{par:blog/urls.py}
\begin{verbatim}
from django.urls import path
from . import views

urlspatterns = [
  path(’’, views.blog),
]
\end{verbatim}


\section{Renderizando templates, html e configurando o INSTALLED\_APPS} % (fold)
\label{sec:Renderizando templates, html e configurando o INSTALLED\_APPS}
A internet tem como padrão para a criação e visualização de sites, o uso
de três tecnologias principais, o HTML, CSS e Javascript, sendo as duas
primeiras linguangens de marcação e a tereceira uma linguagem de pro
gramação. Com isso, para servimos esses tipos de arquivos, precisamos es-
pecificar a existência, e a entrega deles para o request. Para fazermos isso,
precisamos usar a função de render do django, como mostrado a seguir:


\paragraph{blog/views.py} % (fold)
\label{par:blog/views.py}
\begin{verbatim}
from django.shortcuts import render

def home(request):
  return render(
            request,
          ’pastanamespace/arquivo.html’)
\end{verbatim}

Tendo em vista esses elementos, devemos posteriormente dentro do arquivo de 
configurações, adicionar nosso app na lista de apps instalados, para que quando
o django execute, ele possa achar nosso app, e nos permitir acessar o mesmo
pelo navegador


\paragraph{settings.py} % (fold)
\label{par:settings.py}
\begin{verbatim}
INSTALLED\_APPS = [
  'djang.contrib.admin',
  ...,
  'django.contrib.staticfiles',
  'home'
]
\end{verbatim}

Temos então nosso app localizado dentro da nossa aplicação. Com tudo, um erro 
comum dentro do django quando possuímos dois templates com o mesmo nome, apesar 
deles se localizarem em locais diferentes, é que um deles seja escolhido  para 
ser servido aleatoriamente. Com o intuito de evitar isso, é recomendado que dentro 
da nossa pasta do app, e dentro da pasta de templates do app, adicionemos uma outra 
pasta com o nome do nosso app, e coloquemos lá dentro nosso templates, criando assim 
um \textbf{namespace}, elemento que evita que esses erros ocorram.

Com isso, no final teremos dentro de cada app nosso, uma pasta que deve conter os 
templates referentes àquela aplicação, e dento dessa pasta de templates, teremos a 
pasta de namespace com nossos arquivos de html.

\subsection{Configuração de templates globais e Herança de Templates} % (fold)
\label{sub:Configuração de templates globais e Herança de Templates}
Quando estamos criando um projeto, podemos criar pastas para separarmos os templates 
os quais utilizamos, e podemos criar pastas dentro dessa pasta de template, para 
organizar esses templates confome a sua funcionalidade. 

Assim, quando formos usar determinados arquivos para a construção da nossa aplicação 
web, podemos fazer com que esses arquivos sejam reutilizados em outras partes do nosso site, pois podemos extender esses arquivos, como será mostrado a seguir: 


\paragraph{index.html} % (fold)
\label{par:index.html}
% paragraph index.html (end)
\begin{verbatim}
  
  <!DOCTYPE HTML>
  <html lang="pt-br">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
  <body>
    <h1>Escrevendo um título na página</h1>
  </body>
  </html>
\end{verbatim}

\paragraph{page.html} % (fold)
\label{par:page.html}

% paragraph page.html (end)

\begin{verbatim}
  {%extends "pastanamespace/index.html"%}

\end{verbatim}

É bom que nós quando formos criar as pastas e formos criar nossos templates, dentro da 
pasta de template criarmos novamente outra pasta, mas que deve er em si especificamente 
o nome do aplicativo o qual ela faz parte, pois isso previne que nós criemos problemas 
de conflito de busca dos templates pois eles funcionam como namespaces.
% subsection Configuração de templates globais e Herança de Templates (end)

\subsection{Arquivos parciais e o comando include} % (fold)
\label{sub:Arquivos parciais e o comando include}
Dentro da forma como trabalhamos com os templates dentro do Django, podemos ter que 
esses templates podem ser separados em diversos arquivos, e que conforme as 
necessidades da aplicação ele são montados com determinados elementos. Para podermos
usar esses elementos, podemos criar uma pasta dentro da pasta global, com todos os 
arquivos parciais do nosso projeto, por exemplo, e a partir disso criar um sistema de 
"baterias" dentro do nosso projeto. 

Esse tipo de funcionaldiade é permitida por causa do comando \texttt{include} do django,
o qual permite que nós incluamos determinadas partes de de código quando necessário 


\begin{verbatim}
{% include 'global/partials/head.html'%}

<h1>
O head do texto la na inclusão, ou seja. não há necessidade de digitá-lo
</h1>
</body>
</html>
\end{verbatim}
% subsection Arquivos parciais e o comando include (end)

\subsection{Trabalhando com arquivos estáticos} % (fold)
\label{sub:Trabalhando com arquivos estáticos}
Quando estamos trabalhando com arquivos estáticos, como fotos por exemplo, precisamos 
especificar a sua existência e seu tipo de funcionamento para o django, e podemos fazer 
isso definido dentro da pasta a qual falamos que seria a base das templates, uma nova 
pasta que será onde iremos armazenar nossos arquivos estáticos.

Para acessar os arquivos estáticos dentro da nossa página HTML, precisamos 
primeira- 
mente carregar os arquivos por meio do comando \texttt{load}, e ao carregar nossa pasta, 
podemos usar os arquivos por meio do comando:

\begin{verbatim}
  {% load static %}<!DOCTYPE html>
  <html lang="pt-br">
  <head>
  <meta charset="UTF-8">
  <title>Document</title>
  <link rel="stylesheet" href="{% static 'nomedapasta/arquivo'}">
  </head>
\end{verbatim}
% subsection Trabalhando com arquivos estáticos (end)

\subsection{usando o context para enviar dados para dentro dos templates} % (fold)
\label{sub:usando o context para enviar dados para dentro dos templates}
O context, é uma forma de passarmos informações entre os templates da nossa aplicação, 
de forma correta, limpa, e rápida, e isso pode ser feito dentro do arquivo de 
visualização dos templates do nosso app da seguinte forma:


\paragraph{views.py} % (fold)
\label{par:views.py}
\begin{verbatim}
from django.shortcuts import render 

def home(request):
  return render(
            request,
            'home/index.html',
            {'text':'texto sendo passado pelo contexto'}
  )
\end{verbatim}


\paragraph{index.html} % (fold)
\label{par:index.html}
\begin{verbatim}
  <h1>{{ text }}</h1>
\end{verbatim}

% subsection usando o context para enviar dados para dentro dos templates (end)

\subsection{URLs Dinâmicas} % (fold)
\label{sub:URLs Dinâmicas}
Dento do desenvolvimento web, podemos especificar links por meio dos seus endereços 
de forma completa, entretanto o Django permite que nós façamos isso de forma dinâmica, 
ou seja, possamos definir as URLs do nosso site de forma dinãmica, sem ter que especificar
cada uma da das partes para cada um dos possíveis cenários existentes.

Para fazermos isso dentro do Django de forma correta, podemos usar o seguinte código: 


\paragraph{index.html} % (fold)
\label{par:index.html} 
\begin{verbatim}
<nav>
  <ul>
    <li>
      <a href=" {% url 'home' %}">Home</a>
    </li>
    <li>
      <a href="{% url 'blog' %}">Blog</a>
    </li>
  </ul>
</nav>
\end{verbatim}

\paragraph{urls.py} % (fold)
\label{par:urls.py}
\begin{verbatim}
from django.urls import path
from . import views 

urlpatterns = [
  path('', views.home, name="home")
]
\end{verbatim}

Entretanto, podemos colocar para facilitar o entendimento quando tivermos estruturas 
de páginas parecidas em diversas partes da aplicação, colocarmos namespaces dentro do 
arquivo de visualizações, e assim dentro do link colocar o namespace, oque facilitaria 
assim a construção da aplicaão quando formos dar o nome dos links, deixando eles de 
forma mais lógica

\paragraph{index.html} % (fold)
\label{par:index.html}
\begin{verbatim}
  <nav>
    <ul>
      <li>
        <a href="{% url "blog:home" %}">Home</a>
      </li>
    </ul>
  </nav>
\end{verbatim}
% paragraph index.html (end)

\paragraph{urls.py} % (fold)
\label{par:urls.py}
\begin{verbatim}
from django.urls import path
from . import views

app_name = 'blog'
urlpatterns = [
  path('', views.home, name="home")
]
\end{verbatim}


% paragraph urls.py (end)
Agora podemos dizer sem medo que aqueler link é referente à pagina home do blog, 
sem precisarmos fazer malabarismo com as nomeclaturas existentes, para que não haja 
conflito nas URLs. 
% subsection URLs Dinâmicas (end)


\end{document}
